<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.55.5" />
  <link rel="canonical" href="https://hoangtranson.github.io/my-blog/blogs/clean-code-javascript/">

  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="https://hoangtranson.github.io/my-blog/css/prism.css" media="none" onload="this.media='all';">

  
  
  <link rel="stylesheet" type="text/css" href="https://hoangtranson.github.io/my-blog/css/styles.css">

  <style id="inverter" media="none">
    html { filter: invert(100%) }
    * { background-color: inherit }
    img:not([src*=".svg"]), .colors, iframe, .demo-container { filter: invert(100%) }
  </style>

  
  
  <title>Clean Code Javascript | Hoang Tran Blog</title>
</head>

  <body>
    <a href="#main">skip to content</a>
    <svg style="display: none">
  <symbol id="bookmark" viewBox="0 0 40 50">
   <g transform="translate(2266 3206.2)">
    <path style="stroke:currentColor;stroke-width:3.2637;fill:none" d="m-2262.2-3203.4-.2331 42.195 16.319-16.318 16.318 16.318.2331-42.428z"/>
   </g>
  </symbol>

  <symbol id="w3c" viewBox="0 0 127.09899 67.763">
   <text font-size="83" style="font-size:83px;font-family:Trebuchet;letter-spacing:-12;fill-opacity:0" letter-spacing="-12" y="67.609352" x="-26.782778">W3C</text>
   <text font-size="83" style="font-size:83px;font-weight:bold;font-family:Trebuchet;fill-opacity:0" y="67.609352" x="153.21722" font-weight="bold">SVG</text>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m33.695.377 12.062 41.016 12.067-41.016h8.731l-19.968 67.386h-.831l-12.48-41.759-12.479 41.759h-.832l-19.965-67.386h8.736l12.061 41.016 8.154-27.618-3.993-13.397h8.737z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m91.355 46.132c0 6.104-1.624 11.234-4.862 15.394-3.248 4.158-7.45 6.237-12.607 6.237-3.882 0-7.263-1.238-10.148-3.702-2.885-2.47-5.02-5.812-6.406-10.022l6.82-2.829c1.001 2.552 2.317 4.562 3.953 6.028 1.636 1.469 3.56 2.207 5.781 2.207 2.329 0 4.3-1.306 5.909-3.911 1.609-2.606 2.411-5.738 2.411-9.401 0-4.049-.861-7.179-2.582-9.399-1.995-2.604-5.129-3.912-9.397-3.912h-3.327v-3.991l11.646-20.133h-14.062l-3.911 6.655h-2.493v-14.976h32.441v4.075l-12.31 21.217c4.324 1.385 7.596 3.911 9.815 7.571 2.22 3.659 3.329 7.953 3.329 12.892z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.21 0 1.414 8.6-5.008 9.583s-1.924-4.064-5.117-6.314c-2.693-1.899-4.447-2.309-7.186-1.746-3.527.73-7.516 4.938-9.258 10.13-2.084 6.21-2.104 9.218-2.178 11.978-.115 4.428.58 7.043.58 7.043s-3.04-5.626-3.011-13.866c.018-5.882.947-11.218 3.666-16.479 2.404-4.627 5.954-7.404 9.114-7.728 3.264-.343 5.848 1.229 7.841 2.938 2.089 1.788 4.213 5.698 4.213 5.698l4.94-9.837z"/>
   <path style="fill:currentColor;image-rendering:optimizeQuality;shape-rendering:geometricPrecision" d="m125.82 48.674s-2.208 3.957-3.589 5.48c-1.379 1.524-3.849 4.209-6.896 5.555-3.049 1.343-4.646 1.598-7.661 1.306-3.01-.29-5.807-2.032-6.786-2.764-.979-.722-3.486-2.864-4.897-4.854-1.42-2-3.634-5.995-3.634-5.995s1.233 4.001 2.007 5.699c.442.977 1.81 3.965 3.749 6.572 1.805 2.425 5.315 6.604 10.652 7.545 5.336.945 9.002-1.449 9.907-2.031.907-.578 2.819-2.178 4.032-3.475 1.264-1.351 2.459-3.079 3.116-4.108.487-.758 1.276-2.286 1.276-2.286l-1.276-6.644z"/>
  </symbol>

  <symbol id="tag" viewBox="0 0 177.16535 177.16535">
    <g transform="translate(0 -875.2)">
     <path style="fill-rule:evenodd;stroke-width:0;fill:currentColor" d="m159.9 894.3-68.79 8.5872-75.42 77.336 61.931 60.397 75.429-76.565 6.8495-69.755zm-31.412 31.835a10.813 10.813 0 0 1 1.8443 2.247 10.813 10.813 0 0 1 -3.5174 14.872l-.0445.0275a10.813 10.813 0 0 1 -14.86 -3.5714 10.813 10.813 0 0 1 3.5563 -14.863 10.813 10.813 0 0 1 13.022 1.2884z"/>
    </g>
  </symbol>

  <symbol id="balloon" viewBox="0 0 141.73228 177.16535">
   <g transform="translate(0 -875.2)">
    <g>
     <path style="fill:currentColor" d="m68.156 882.83-.88753 1.4269c-4.9564 7.9666-6.3764 17.321-5.6731 37.378.36584 10.437 1.1246 23.51 1.6874 29.062.38895 3.8372 3.8278 32.454 4.6105 38.459 4.6694-.24176 9.2946.2879 14.377 1.481 1.2359-3.2937 5.2496-13.088 8.886-21.623 6.249-14.668 8.4128-21.264 10.253-31.252 1.2464-6.7626 1.6341-12.156 1.4204-19.764-.36325-12.93-2.1234-19.487-6.9377-25.843-2.0833-2.7507-6.9865-7.6112-7.9127-7.8436-.79716-.20019-6.6946-1.0922-6.7755-1.0248-.02213.0182-5.0006-.41858-7.5248-.22808l-2.149-.22808h-3.3738z"/>
     <path style="fill:currentColor" d="m61.915 883.28-3.2484.4497c-1.7863.24724-3.5182.53481-3.8494.63994-2.4751.33811-4.7267.86957-6.7777 1.5696-.28598 0-1.0254.20146-2.3695.58589-5.0418 1.4418-6.6374 2.2604-8.2567 4.2364-6.281 7.6657-11.457 18.43-12.932 26.891-1.4667 8.4111.71353 22.583 5.0764 32.996 3.8064 9.0852 13.569 25.149 22.801 37.517 1.3741 1.841 2.1708 2.9286 2.4712 3.5792 3.5437-1.1699 6.8496-1.9336 10.082-2.3263-1.3569-5.7831-4.6968-21.86-6.8361-33.002-.92884-4.8368-2.4692-14.322-3.2452-19.991-.68557-5.0083-.77707-6.9534-.74159-15.791.04316-10.803.41822-16.162 1.5026-21.503 1.4593-5.9026 3.3494-11.077 6.3247-15.852z"/>
     <path style="fill:currentColor" d="m94.499 885.78c-.10214-.0109-.13691 0-.0907.0409.16033.13489 1.329 1.0675 2.5976 2.0723 6.7003 5.307 11.273 14.568 12.658 25.638.52519 4.1949.24765 14.361-.5059 18.523-2.4775 13.684-9.7807 32.345-20.944 53.519l-3.0559 5.7971c2.8082.76579 5.7915 1.727 8.9926 2.8441 11.562-11.691 18.349-19.678 24.129-28.394 7.8992-11.913 11.132-20.234 12.24-31.518.98442-10.02-1.5579-20.876-6.7799-28.959-.2758-.4269-.57803-.86856-.89617-1.3166-3.247-6.13-9.752-12.053-21.264-16.131-2.3687-.86369-6.3657-2.0433-7.0802-2.1166z"/>
     <path style="fill:currentColor" d="m32.52 892.22c-.20090-.13016-1.4606.81389-3.9132 2.7457-11.486 9.0476-17.632 24.186-16.078 39.61.79699 7.9138 2.4066 13.505 5.9184 20.562 5.8577 11.77 14.749 23.219 30.087 38.74.05838.059.12188.1244.18052.1838 1.3166-.5556 2.5965-1.0618 3.8429-1.5199-.66408-.32448-1.4608-1.3297-3.8116-4.4602-5.0951-6.785-8.7512-11.962-13.051-18.486-5.1379-7.7948-5.0097-7.5894-8.0586-13.054-6.2097-11.13-8.2674-17.725-8.6014-27.563-.21552-6.3494.13041-9.2733 1.775-14.987 2.1832-7.5849 3.9273-10.986 9.2693-18.07 1.7839-2.3656 2.6418-3.57 2.4409-3.7003z"/>
     <path style="fill:currentColor" d="m69.133 992.37c-6.2405.0309-12.635.76718-19.554 2.5706 4.6956 4.7759 9.935 10.258 12.05 12.625l4.1272 4.6202h11.493l3.964-4.4516c2.0962-2.3541 7.4804-7.9845 12.201-12.768-8.378-1.4975-16.207-2.6353-24.281-2.5955z"/>
     <rect style="stroke-width:0;fill:currentColor" ry="2.0328" height="27.746" width="22.766" y="1017.7" x="60.201"/>
    </g>
   </g>
  </symbol>

  <symbol id="info" viewBox="0 0 41.667 41.667">
   <g transform="translate(-37.035 -1004.6)">
    <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m76.25 1030.2a18.968 18.968 0 0 1 -23.037 13.709 18.968 18.968 0 0 1 -13.738 -23.019 18.968 18.968 0 0 1 23.001 -13.768 18.968 18.968 0 0 1 13.798 22.984"/>
    <g transform="matrix(1.1146 0 0 1.1146 -26.276 -124.92)">
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:3.728;fill:none" d="m75.491 1039.5v-8.7472"/>
     <path style="stroke-width:0;fill:currentColor" transform="scale(-1)" d="m-73.193-1024.5a2.3719 2.3719 0 0 1 -2.8807 1.7142 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"/>
    </g>
   </g>
  </symbol>

  <symbol id="warning" viewBox="0 0 48.430474 41.646302">
    <g transform="translate(-1.1273 -1010.2)">
     <path style="stroke-linejoin:round;stroke:currentColor;stroke-linecap:round;stroke-width:4.151;fill:none" d="m25.343 1012.3-22.14 37.496h44.28z"/>
     <path style="stroke:currentColor;stroke-linecap:round;stroke-width:4.1512;fill:none" d="m25.54 1027.7v8.7472"/>
     <path style="stroke-width:0;fill:currentColor" d="m27.839 1042.8a2.3719 2.3719 0 0 1 -2.8807 1.7143 2.3719 2.3719 0 0 1 -1.718 -2.8785 2.3719 2.3719 0 0 1 2.8763 -1.7217 2.3719 2.3719 0 0 1 1.7254 2.8741"/>
    </g>
  </symbol>

  <symbol id="menu" viewBox="0 0 50 50">
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="0" x="0"/>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="20" x="0"/>
     <rect style="stroke-width:0;fill:currentColor" height="10" width="50" y="40" x="0"/>
   </symbol>

   <symbol id="link" viewBox="0 0 50 50">
    <g transform="translate(0 -1002.4)">
     <g transform="matrix(.095670 0 0 .095670 2.3233 1004.9)">
      <g>
       <path style="stroke-width:0;fill:currentColor" d="m452.84 192.9-128.65 128.65c-35.535 35.54-93.108 35.54-128.65 0l-42.881-42.886 42.881-42.876 42.884 42.876c11.845 11.822 31.064 11.846 42.886 0l128.64-128.64c11.816-11.831 11.816-31.066 0-42.9l-42.881-42.881c-11.822-11.814-31.064-11.814-42.887 0l-45.928 45.936c-21.292-12.531-45.491-17.905-69.449-16.291l72.501-72.526c35.535-35.521 93.136-35.521 128.64 0l42.886 42.881c35.535 35.523 35.535 93.141-.001 128.66zm-254.28 168.51-45.903 45.9c-11.845 11.846-31.064 11.817-42.881 0l-42.884-42.881c-11.845-11.821-11.845-31.041 0-42.886l128.65-128.65c11.819-11.814 31.069-11.814 42.884 0l42.886 42.886 42.876-42.886-42.876-42.881c-35.54-35.521-93.113-35.521-128.65 0l-128.65 128.64c-35.538 35.545-35.538 93.146 0 128.65l42.883 42.882c35.51 35.54 93.11 35.54 128.65 0l72.496-72.499c-23.956 1.597-48.092-3.784-69.474-16.283z"/>
      </g>
     </g>
    </g>
  </symbol>

  <symbol id="doc" viewBox="0 0 35 45">
   <g transform="translate(-147.53 -539.83)">
    <path style="stroke:currentColor;stroke-width:2.4501;fill:none" d="m149.38 542.67v39.194h31.354v-39.194z"/>
    <g style="stroke-width:25" transform="matrix(.098003 0 0 .098003 133.69 525.96)">
     <path d="m220 252.36h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
     <path style="stroke:currentColor;stroke-width:25;fill:none" d="m220 409.95h200"/>
     <path d="m220 488.74h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
     <path d="m220 331.15h200" style="stroke:currentColor;stroke-width:25;fill:none"/>
    </g>
   </g>
 </symbol>

 <symbol id="tick" viewBox="0 0 177.16535 177.16535">
  <g transform="translate(0 -875.2)">
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="155" width="40" y="702.99" x="556.82"/>
   <rect style="stroke-width:0;fill:currentColor" transform="rotate(30)" height="40" width="90.404" y="817.99" x="506.42"/>
  </g>
 </symbol>
</svg>

    <div class="wrapper">
      <header class="intro-and-nav" role="banner">
  <div>
    <div class="intro">
      <a class="logo" href="/my-blog/" aria-label="Hoang Tran Blog home page">
        <img src="https://hoangtranson.github.io/my-blog/img/avatar.jpg" alt="">
      </a>
      <p class="library-desc">
          Frontend Developer üíª <br/> 
          Software Philosopher üìñ <br/>
          <a href="https://stackoverflow.com/users/4344732/hoang-tran-son" aria-label="Hoang stackoverflow">
            Stackoverflow
          </a> <br/>
          <a href="https://github.com/hoangtranson" aria-label="Hoang github">
            Github
          </a> <br/>
          <a href="mailto:hayden.tran.d@gmail.com">hayden.tran.d@gmail.com</a>
        
      </p>
    </div>
    <nav id="patterns-nav" class="patterns" role="navigation">
  <h2 class="vh">Main navigation</h2>
  <button id="menu-button" aria-expanded="false">
    <svg viewBox="0 0 50 50" aria-hidden="true" focusable="false">
      <use xlink:href="#menu"></use>
    </svg>
    Menu
  </button>
  
  <ul id="patterns-list">
  
    <li class="pattern">
      
      
      
      
      <a href="/my-blog/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Home</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/my-blog/blogs/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Blogs</span>
      </a>
    </li>
  
    <li class="pattern">
      
      
      
      
      <a href="/my-blog/tags/" >
        <svg class="bookmark-icon" aria-hidden="true" focusable="false" viewBox="0 0 40 50">
          <use xlink:href="#bookmark"></use>
        </svg>
        <span class="text">Tags</span>
      </a>
    </li>
  
  </ul>
</nav>
  </div>
</header>
      <div class="main-and-footer">
        <div>
          
  <main id="main">
    <h1>Clean Code Javascript</h1>
    <p>Software engineering principles, from Robert C. Martin&rsquo;s book Clean Code.</p>

<h3 id="table-of-content">Table of content</h3>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#summary">Summary and Integrate to PR</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#solid">SOLID</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#concurrency">Concurrency</a></li>
<li><a href="#errorhandling">Error Handling</a></li>
<li><a href="#formatting">Formatting</a></li>
<li><a href="#comments">Comments</a></li>
</ul>

<h4 id="introduction-a-name-introduction-a">Introduction <a name="introduction"></a></h4>

<p>This topic based on <a href="https://github.com/ryanmcdermott/clean-code-javascript">Clean code javascript</a> from Ryanmc Dermott. Thanks to his great work. I created my check list for javascript from this great resource and this help me a lot in reducing bugs and optimize my code. That&rsquo;s why I wanna share this to persons who is working as Front-end engineering like me.</p>

<h4 id="summary-and-integrate-to-pr-a-name-summary-a">Summary and Integrate to PR <a name="summary"></a></h4>

<p>Here is check list that I created by myself.</p>

<pre><code class="language-Markdown">Variables
- [ ] Use meaningful and pronounceable variable names
- [ ] Use the same vocabulary for the same type of variable
- [ ] Use searchable names
- [ ] Avoid Mental Mapping
- [ ] Don't add unneeded context
- [ ] Use default arguments instead of short circuiting or conditionals

Functions
- [ ] Function arguments (2 or fewer ideally)
- [ ] Functions should do one thing
- [ ] Function names should say what they do
- [ ] Remove duplicate code
- [ ] Set default objects with Object.assign
- [ ] Don't use flags as function parameters
- [ ] Favor functional programming over imperative programming
- [ ] Encapsulate conditionals
- [ ] Avoid negative conditionals
- [ ] Avoid conditionals
- [ ] Avoid type-checking
- [ ] Remove dead code

Classes
- [ ] Prefer ES2015/ES6 classes over ES5 plain functions
- [ ] Use method chaining
- [ ] Prefer composition over inheritance

SOLID
- [ ] Single Responsibility Principle (SRP)
- [ ] Open/Closed Principle (OCP)
- [ ] Liskov Substitution Principle (LSP)
- [ ] Interface Segregation Principle (ISP)
- [ ] Dependency Inversion Principle (DIP)

Testing
- [ ] Single concept per test

Concurrency
- [ ] Use Promises, not callbacks

Error Handling
- [ ] Don't ignore caught errors
- [ ] Don't ignore rejected promises

Formatting
- [ ] Use consistent capitalization
- [ ] Function callers and callees should be close

Comments
- [ ] Only comment things that have business logic complexity.
- [ ] Don't leave commented out code in your codebase
- [ ] Don't have journal comments
- [ ] Avoid positional markers
</code></pre>

<p><img src="/my-blog/img/portfolio/content5/img1.jpg" alt="image 1" /></p>

<p><img src="/my-blog/img/portfolio/content5/img2.jpg" alt="image 2" /></p>

<p>So I use this as check list whenever I create pull request to important branchs.</p>

<p>References:</p>

<ol>
<li><a href="https://blog.github.com/2016-02-17-issue-and-pull-request-templates/">https://blog.github.com/2016-02-17-issue-and-pull-request-templates/</a></li>
<li><a href="https://help.github.com/articles/creating-a-pull-request-template-for-your-repository/">https://help.github.com/articles/creating-a-pull-request-template-for-your-repository/</a></li>
</ol>

<h4 id="variables-a-name-variables-a">Variables <a name="variables"></a></h4>

<ol>
<li><p>Use meaningful and pronounceable variable names</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">const yyyymmdstr = moment().format('YYYY/MM/DD');
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">const currentDate = moment().format('YYYY/MM/DD'); // change var name more meaning
</code></pre></li>

<li><p>Use the same vocabulary for the same type of variable</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">getUserInfo();
getClientData();
getCustomerRecord();
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">getUser();
</code></pre></li>

<li><p>Use searchable names</p>

<p>We will read more code than we will ever write. It&rsquo;s important that the code we do write is readable and searchable. By not naming variables that end up being meaningful for understanding our program, we hurt our readers. Make your names searchable. Tools like <a href="https://github.com/danielstjules/buddy.js">buddy.js</a> and <a href="https://github.com/eslint">ESLint</a> can help identify unnamed constants.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">setTimeout(blastOff, 86400000);
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">const MILLISECONDS_IN_A_DAY = 86400000; // create MILLISECONDS_IN_A_DAY for 86400000
setTimeout(blastOff, MILLISECONDS_IN_A_DAY);
</code></pre></li>

<li><p>Avoid Mental Mapping
Explicit is better than implicit.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">const locations = ['Austin', 'New York', 'San Francisco'];
locations.forEach((l) =&gt; {
    doStuff();
    doSomeOtherStuff();
    dispatch(l);
});
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">const locations = ['Austin', 'New York', 'San Francisco'];
locations.forEach((location) =&gt; { // change l to location
    doStuff();
    doSomeOtherStuff();
    dispatch(location);
});
</code></pre></li>

<li><p>Don&rsquo;t add unneeded context
If your class/object name tells you something, don&rsquo;t repeat that in your variable name.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">const Car = {
    carMake: 'Honda',
    carModel: 'Accord',
    carColor: 'Blue'
};

paintCar(car) {
    car.carColor = 'Red';
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">const Car = {
    make: 'Honda',
    model: 'Accord',
    color: 'Blue'
};

paintCar(car) {
    car.carColor = 'Red';
}
</code></pre></li>

<li><p>Use default arguments instead of short circuiting or conditionals
Default arguments are often cleaner than short circuiting. Be aware that if you use them, your function will only provide default values for undefined arguments. Other &ldquo;falsy&rdquo; values such as &ldquo;, &ldquo;&rdquo;, false, null, 0, and NaN, will not be replaced by a default value.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">createMicrobrewery(name) {
    const breweryName = name || 'Hipster Brew Co.';
    ...
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">createMicrobrewery(name = 'Hipster Brew Co.') {
    ...
}
</code></pre></li>
</ol>

<h4 id="functions-a-name-functions-a">Functions <a name="functions"></a></h4>

<ol>
<li><p>Function arguments (2 or fewer ideally)</p>

<p>Limiting the amount of function parameters is incredibly important because it makes testing your function easier. Having more than three leads to a combinatorial explosion where you have to test tons of different cases with each separate argument.</p>

<p>One or two arguments is the ideal case, and three should be avoided if possible. Anything more than that should be consolidated. Usually, if you have more than two arguments then your function is trying to do too much. In cases where it&rsquo;s not, most of the time a higher-level object will suffice as an argument.</p>

<p>Since JavaScript allows you to make objects on the fly, without a lot of class boilerplate, you can use an object if you are finding yourself needing a lot of arguments.</p>

<p>To make it obvious what properties the function expects, you can use the ES2015/ES6 destructuring syntax. This has a few advantages:</p>

<ul>
<li>When someone looks at the function signature, it&rsquo;s immediately clear what properties are being used.</li>
<li>Destructuring also clones the specified primitive values of the argument object passed into the function. This can help prevent side effects. Note: objects and arrays that are destructured from the argument object are NOT cloned.</li>
<li>Linters can warn you about unused properties, which would be impossible without destructuring.</li>
</ul>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">createMenu(title, body, buttonText, cancellable) {
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">createMenu({ title, body, buttonText, cancellable }) {
}

createMenu({
    title: 'Foo',
    body: 'Bar',
    buttonText: 'Baz',
    cancellable: true
});
</code></pre></li>

<li><p>Functions should do one thing</p>

<p>This is by far the most important rule in software engineering. When functions do more than one thing, they are harder to compose, test, and reason about. When you can isolate a function to just one action, they can be refactored easily and your code will read much cleaner. If you take nothing else away from this guide other than this, you&rsquo;ll be ahead of many developers.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">emailClients(clients) {
    clients.forEach((client) =&gt; {
        const clientRecord = database.lookup(client);
        if (clientRecord.isActive()) {
            email(client);
        }
    });
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">emailActiveClients(clients) {
    clients
        .filter(isActiveClient)
        .forEach(email);
    }

isActiveClient(client) {
    const clientRecord = database.lookup(client);
    return clientRecord.isActive();
}
</code></pre></li>

<li><p>Function names should say what they do</p>

<p>It&rsquo;s hard to tell from the function name what is added</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">addToDate(date, month) {}
const date = new Date();
addToDate(date, 1);
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">addMonthToDate(month, date) {}
const date = new Date();
addMonthToDate(1, date)
</code></pre></li>

<li><p>Remove duplicate code
Do your absolute best to avoid duplicate code. Duplicate code is bad because it means that there&rsquo;s more than one place to alter something if you need to change some logic.</p>

<p>Imagine if you run a restaurant and you keep track of your inventory: all your tomatoes, onions, garlic, spices, etc. If you have multiple lists that you keep this on, then all have to be updated when you serve a dish with tomatoes in them. If you only have one list, there&rsquo;s only one place to update!</p>

<p>Oftentimes you have duplicate code because you have two or more slightly different things, that share a lot in common, but their differences force you to have two or more separate functions that do much of the same things. Removing duplicate code means creating an abstraction that can handle this set of different things with just one function/module/class.</p>

<p>Getting the abstraction right is critical, that&rsquo;s why you should follow the SOLID principles laid out in the Classes section. Bad abstractions can be worse than duplicate code, so be careful! Having said this, if you can make a good abstraction,do it! Don&rsquo;t repeat yourself, otherwise you&rsquo;ll find yourself updating multiple places anytime you want to change one thing.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">showDeveloperList(developers) {
    developers.forEach((developer) =&gt; {
        const expectedSalary = developer.calculateExpectedSalary();
        const experience = developer.getExperience();
        const githubLink = developer.getGithubLink();
        const data = {
        expectedSalary,
        experience,
        githubLink
        };

        render(data);
    });
}

showManagerList(managers) {
    managers.forEach((manager) =&gt; {
        const expectedSalary = manager.calculateExpectedSalary();
        const experience = manager.getExperience();
        const portfolio = manager.getMBAProjects();
        const data = {
        expectedSalary,
        experience,
        portfolio
        };

        render(data);
    });
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">showEmployeeList(employees) {
    employees.forEach((employee) =&gt; {
        const expectedSalary = employee.calculateExpectedSalary();
        const experience = employee.getExperience();

        const data = {
        expectedSalary,
        experience
        };

        switch (employee.type) {
        case 'manager':
            data.portfolio = employee.getMBAProjects();
            break;
        case 'developer':
            data.githubLink = employee.getGithubLink();
            break;
        }

        render(data);
    });
}
</code></pre></li>

<li><p>Set default objects with Object.assign
BAD CODE:</p>

<pre><code class="language-Javascript">const menuConfig = {
    title: null,
    body: 'Bar',
    buttonText: null,
    cancellable: true
};

createMenu(config) {
    config.title = config.title || 'Foo';
    config.body = config.body || 'Bar';
    config.buttonText = config.buttonText || 'Baz';
    config.cancellable = config.cancellable !== undefined ? config.cancellable : true;
}

createMenu(menuConfig);
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">const menuConfig = {
    title: 'Order',
    buttonText: 'Send',
    cancellable: true
};

createMenu(config) {
    config = Object.assign({
        title: 'Foo',
        body: 'Bar',
        buttonText: 'Baz',
        cancellable: true
    }, config);
}

createMenu(menuConfig);
</code></pre></li>

<li><p>Don&rsquo;t use flags as function parameters</p>

<p>Flags tell your user that this function does more than one thing. Functions should do one thing. Split out your functions if they are following different code paths based on a boolean.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">createFile(name, temp) {
    if (temp) {
        fs.create(`./temp/${name}`);
    } else {
        fs.create(name);
    }
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">createFile(name) {
    fs.create(name);
}

createTempFile(name) {
    createFile(`./temp/${name}`);
}
</code></pre></li>

<li><p>Favor functional programming over imperative programming</p>

<p>JavaScript isn&rsquo;t a functional language in the way that Haskell is, but it has a functional flavor to it. Functional languages can be cleaner and easier to test. Favor this style of programming when you can.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">const programmerOutput = [
    {
        name: 'Uncle Bobby',
        linesOfCode: 500
    }, {
        name: 'Suzie Q',
        linesOfCode: 1500
    }, {
        name: 'Jimmy Gosling',
        linesOfCode: 150
    }, {
        name: 'Gracie Hopper',
        linesOfCode: 1000
    }
];

let totalOutput = 0;

for (let i = 0; i &lt; programmerOutput.length; i++) {
    totalOutput += programmerOutput[i].linesOfCode;
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">const programmerOutput = [
    {
        name: 'Uncle Bobby',
        linesOfCode: 500
    }, {
        name: 'Suzie Q',
        linesOfCode: 1500
    }, {
        name: 'Jimmy Gosling',
        linesOfCode: 150
    }, {
        name: 'Gracie Hopper',
        linesOfCode: 1000
    }
];

const totalOutput = programmerOutput
.map(output =&gt; output.linesOfCode)
.reduce((totalLines, lines) =&gt; totalLines + lines);
</code></pre></li>

<li><p>Encapsulate conditionals
BAD CODE:</p>

<pre><code class="language-Javascript">if (fsm.state === 'fetching' &amp;&amp; isEmpty(listNode)) {}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">shouldShowSpinner(fsm, listNode) {
    return fsm.state === 'fetching' &amp;&amp; isEmpty(listNode);
}

if (shouldShowSpinner(fsmInstance, listNodeInstance)) {}
</code></pre></li>

<li><p>Avoid negative conditionals
BAD CODE:</p>

<pre><code class="language-Javascript">isDOMNodeNotPresent(node) {}
if (!isDOMNodeNotPresent(node)) {}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">isDOMNodePresent(node) {}

if (isDOMNodePresent(node)) {}
</code></pre></li>

<li><p>Avoid conditionals</p>

<p>This seems like an impossible task. Upon first hearing this, most people say, &ldquo;how am I supposed to do anything without an if statement?&rdquo; The answer is that you can use polymorphism to achieve the same task in many cases. The second question is usually, &ldquo;well that&rsquo;s great but why would I want to do that?&rdquo; The answer is a previous clean code concept we learned: a function should only do one thing. When you have classes and functions that have if statements, you are telling your user that your function does more than one thing. Remember, just do one thing.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class Airplane {
    getCruisingAltitude() {
        switch (this.type) {
            case '777':
                return this.getMaxAltitude() - this.getPassengerCount();
            case 'Air Force One':
                return this.getMaxAltitude();
            case 'Cessna':
                return this.getMaxAltitude() - this.getFuelExpenditure();
        }
    }
}
</code></pre>

<p>There are multiple issues with switch, from its procedural control flow to its non-standard-looking way it handles code blocks, the rest of JavaScript uses curly braces yet switch does not. Syntactically, it‚Äôs not one of JavaScript‚Äôs best, nor is its design. We‚Äôre forced to manually add break; statements within each case, which can lead to difficult debugging and nested errors further down the case should we forget! Douglas Crockford has written and spoken about it numerous times, his recommendations are to treat it with caution.</p>

<p>We often use Object lookups for things in JavaScript, often for things we would never contemplate using switch for - so why not use an Object literal to replace switch? Objects are much more flexible, have better readability and maintainability and we don‚Äôt need to manually break; each ‚Äúcase‚Äù. They‚Äôre a lot friendlier on new JavaScript developers as well, as they‚Äôre standard Objects.</p>

<p>As the number of ‚Äúcases‚Äù increases, the performance of the object (hash table) gets better than the average cost of the switch (the order of the cases matter). The object approach is a hash table lookup, and the switch has to evaluate each case until it hits a match and a break.</p>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class Airplane {
    getCruisingAltitude (type) {
        const CruisingAltitude = {
            '777': () =&gt; {
                return this.getMaxAltitude() - this.getPassengerCount();
            },
            'Air Force One': () =&gt; {
                return this.getMaxAltitude();
            },
            'Cessna': () =&gt; {
                return this.getMaxAltitude() - this.getFuelExpenditure();
            }
        };
        return CruisingAltitude[type]();
    }
}
</code></pre></li>

<li><p>Avoid type-checking</p>

<p>JavaScript is untyped, which means your functions can take any type of argument. Sometimes you are bitten by this freedom and it becomes tempting to do type-checking in your functions. There are many ways to avoid having to do this. The first thing to consider is consistent APIs.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">travelToTexas(vehicle) {
    if (vehicle instanceof Bicycle) {
        vehicle.pedal(this.currentLocation, new Location('texas'));
    } else if (vehicle instanceof Car) {
        vehicle.drive(this.currentLocation, new Location('texas'));
    }
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">travelToTexas(vehicle) {
    vehicle.move(this.currentLocation, new Location('texas'));
}
</code></pre>

<p>If you are working with basic primitive values like strings and integers, and you can&rsquo;t use polymorphism but you still feel the need to type-check, you should consider using TypeScript. It is an excellent alternative to normal JavaScript, as it provides you with static typing on top of standard JavaScript syntax. The problem with manually type-checking normal JavaScript is that doing it well requires so much extra verbiage that the faux &ldquo;type-safety&rdquo; you get doesn&rsquo;t make up for the lost readability. Keep your JavaScript clean, write good tests, and have good code reviews. Otherwise, do all of that but with TypeScript (which, like I said, is a great alternative!).</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">combine(val1, val2) {
    if (typeof val1 === 'number' &amp;&amp; typeof val2 === 'number' ||
        typeof val1 === 'string' &amp;&amp; typeof val2 === 'string') {
        return val1 + val2;
    }
    throw new Error('Must be of type String or Number');
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">combine(val1, val2) {
    return val1 + val2;
}
</code></pre></li>

<li><p>Remove dead code</p>

<p>Dead code is just as bad as duplicate code. There&rsquo;s no reason to keep it in your codebase. If it&rsquo;s not being called, get rid of it! It will still be safe in your version history if you still need it.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">oldRequestModule(url) {}
newRequestModule(url) {}

const req = newRequestModule;
inventoryTracker('apples', req, 'www.inventory-awesome.io');
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">newRequestModule(url) {}

const req = newRequestModule;
inventoryTracker('apples', req, 'www.inventory-awesome.io');
</code></pre></li>
</ol>

<h4 id="classes-a-name-classes-a">Classes <a name="classes"></a></h4>

<ol>
<li><p>Prefer ES2015/ES6 classes over ES5 plain functions</p>

<p>It&rsquo;s very difficult to get readable class inheritance, construction, and method definitions for classical ES5 classes. If you need inheritance (and be aware that you might not), then prefer ES2015/ES6 classes. However, prefer small functions over classes until you find yourself needing larger and more complex objects.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">const Animal = function(age) {
    if (!(this instanceof Animal)) {
        throw new Error('Instantiate Animal with `new`');
    }

    this.age = age;
};

Animal.prototype.move = function move() {};

const Mammal = function(age, furColor) {
    if (!(this instanceof Mammal)) {
        throw new Error('Instantiate Mammal with `new`');
    }

    Animal.call(this, age);
    this.furColor = furColor;
};

Mammal.prototype = Object.create(Animal.prototype);
Mammal.prototype.constructor = Mammal;
Mammal.prototype.liveBirth = function liveBirth() {};

const Human = function(age, furColor, languageSpoken) {
if (!(this instanceof Human)) {
    throw new Error('Instantiate Human with `new`');
}

Mammal.call(this, age, furColor);
    this.languageSpoken = languageSpoken;
};

Human.prototype = Object.create(Mammal.prototype);
Human.prototype.constructor = Human;
Human.prototype.speak = function speak() {};
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class Animal {
    constructor(age) {
        this.age = age;
    }

    move() { /* ... */ }
}

class Mammal extends Animal {
    constructor(age, furColor) {
        super(age);
        this.furColor = furColor;
    }

    liveBirth() { /* ... */ }
}

class Human extends Mammal {
    constructor(age, furColor, languageSpoken) {
        super(age, furColor);
        this.languageSpoken = languageSpoken;
    }

    speak() { /* ... */ }
}
</code></pre></li>

<li><p>Use method chaining</p>

<p>This pattern is very useful in JavaScript and you see it in many libraries such as jQuery and Lodash. It allows your code to be expressive, and less verbose. For that reason, I say, use method chaining and take a look at how clean your code will be. In your class functions, simply return this at the end of every function, and you can chain further class methods onto it.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class Car {
    constructor(make, model, color) {
        this.make = make;
        this.model = model;
        this.color = color;
    }

    setMake(make) {
        this.make = make;
    }

    setModel(model) {
        this.model = model;
    }

    setColor(color) {
        this.color = color;
    }

    save() {
        console.log(this.make, this.model, this.color);
    }
}

const car = new Car('Ford','F-150','red');
car.setColor('pink');
car.save();
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class Car {
    constructor(make, model, color) {
        this.make = make;
        this.model = model;
        this.color = color;
    }

    setMake(make) {
        this.make = make;
        // NOTE: Returning this for chaining
        return this;
    }

    setModel(model) {
        this.model = model;
        // NOTE: Returning this for chaining
        return this;
    }

    setColor(color) {
        this.color = color;
        // NOTE: Returning this for chaining
        return this;
    }

    save() {
        console.log(this.make, this.model, this.color);
        // NOTE: Returning this for chaining
        return this;
    }
}

const car = new Car('Ford','F-150','red')
.setColor('pink')
.save();
</code></pre></li>

<li><p>Prefer composition over inheritance</p>

<p>As stated famously in Design Patterns by the Gang of Four, you should prefer composition over inheritance where you can. There are lots of good reasons to use inheritance and lots of good reasons to use composition. The main point for this maxim is that if your mind instinctively goes for inheritance, try to think if composition could model your problem better. In some cases it can.</p>

<p>You might be wondering then, &ldquo;when should I use inheritance?&rdquo; It depends on your problem at hand, but this is a decent list of when inheritance makes more sense than composition:</p>

<ul>
<li>Your inheritance represents an &ldquo;is-a&rdquo; relationship and not a &ldquo;has-a&rdquo; relationship (Human-&gt;Animal vs. User-&gt;UserDetails).</li>
<li>You can reuse code from the base classes (Humans can move like all animals).</li>
<li>You want to make global changes to derived classes by changing a base class. (Change the caloric expenditure of all animals when they move).</li>
</ul>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class Employee {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }
}

// Bad because Employees &quot;have&quot; tax data. EmployeeTaxData is not a type of Employee

class EmployeeTaxData extends Employee {
    constructor(ssn, salary) {
        super();
        this.ssn = ssn;
        this.salary = salary;
    }
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class EmployeeTaxData {
    constructor(ssn, salary) {
        this.ssn = ssn;
        this.salary = salary;
    }
}

class Employee {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }

    setTaxData(ssn, salary) {
        this.taxData = new EmployeeTaxData(ssn, salary);
    }
}
</code></pre></li>
</ol>

<h4 id="solid-a-name-solid-a">SOLID <a name="solid"></a></h4>

<ol>
<li><p>Single Responsibility Principle (SRP)
As stated in Clean Code, &ldquo;There should never be more than one reason for a class to change&rdquo;. It&rsquo;s tempting to jam-pack a class with a lot of functionality, like when you can only take one suitcase on your flight. The issue with this is that your class won&rsquo;t be conceptually cohesive and it will give it many reasons to change. Minimizing the amount of times you need to change a class is important. It&rsquo;s important because if too much functionality is in one class and you modify a piece of it, it can be difficult to understand how that will affect other dependent modules in your codebase.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class UserSettings {
    constructor(user) {
        this.user = user;
    }

    changeSettings(settings) {
        if (this.verifyCredentials()) {}
    }

    verifyCredentials() {}
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class UserAuth {
    constructor(user) {
        this.user = user;
    }

    verifyCredentials() {}
}

class UserSettings {
    constructor(user) {
        this.user = user;
        this.auth = new UserAuth(user);
    }

    changeSettings(settings) {
        if (this.auth.verifyCredentials()) {}
    }
}
</code></pre></li>

<li><p>Open/Closed Principle (OCP)</p>

<p>As stated by Bertrand Meyer, &ldquo;software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.&rdquo; What does that mean though? This principle basically states that you should allow users to add new functionalities without changing existing code.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class AjaxAdapter extends Adapter {
    constructor() {
        super();
        this.name = 'ajaxAdapter';
    }
}

class NodeAdapter extends Adapter {
    constructor() {
        super();
        this.name = 'nodeAdapter';
    }
}

class HttpRequester {
    constructor(adapter) {
        this.adapter = adapter;
    }

    fetch(url) {
        if (this.adapter.name === 'ajaxAdapter') {
            return makeAjaxCall(url).then((response) =&gt; {

                // transform response and return

            });
        } else if (this.adapter.name === 'httpNodeAdapter') {
            return makeHttpCall(url).then((response) =&gt; {

                // transform response and return

            });
        }
    }
}

function makeAjaxCall(url) {

    // request and return promise

}

function makeHttpCall(url) {

    // request and return promise

}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class AjaxAdapter extends Adapter {
    constructor() {
        super();
        this.name = 'ajaxAdapter';
    }

    request(url) {

        // request and return promise

    }
}

class NodeAdapter extends Adapter {
    constructor() {
        super();
        this.name = 'nodeAdapter';
    }

    request(url) {

        // request and return promise

    }
}

class HttpRequester {
    constructor(adapter) {
        this.adapter = adapter;
    }

    fetch(url) {
        return this.adapter.request(url).then((response) =&gt; {

            // transform response and return

        });
    }
}
</code></pre></li>

<li><p>Liskov Substitution Principle (LSP)</p>

<p>This is a scary term for a very simple concept. It&rsquo;s formally defined as &ldquo;If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).&rdquo; That&rsquo;s an even scarier definition.</p>

<p>The best explanation for this is if you have a parent class and a child class, then the base class and child class can be used interchangeably without getting incorrect results. This might still be confusing, so let&rsquo;s take a look at the classic Square-Rectangle example. Mathematically, a square is a rectangle, but if you model it using the &ldquo;is-a&rdquo; relationship via inheritance, you quickly get into trouble.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class Rectangle {
    constructor() {
        this.width = 0;
        this.height = 0;
    }

    setColor(color) {
    }

    render(area) {
    }

    setWidth(width) {
        this.width = width;
    }

    setHeight(height) {
        this.height = height;
    }

    getArea() {
        return this.width * this.height;
    }
}

class Square extends Rectangle {
    setWidth(width) {
        this.width = width;
        this.height = width;
    }

    setHeight(height) {
        this.width = height;
        this.height = height;
    }
}

renderLargeRectangles(rectangles) {
    rectangles.forEach((rectangle) =&gt; {
        rectangle.setWidth(4);
        rectangle.setHeight(5);
        const area = rectangle.getArea(); // BAD: Returns 25 for Square. Should be 20.

        rectangle.render(area);

    });
}

const rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles(rectangles);
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class Shape {
    setColor(color) {
    }

    render(area) {
    }
}

class Rectangle extends Shape {
    constructor(width, height) {
        super();
        this.width = width;
        this.height = height;
    }

    getArea() {
        return this.width * this.height;
    }
}

class Square extends Shape {
    constructor(length) {
        super();
        this.length = length;
    }

    getArea() {
        return this.length * this.length;
    }
}

renderLargeShapes(shapes) {
    shapes.forEach((shape) =&gt; {
        const area = shape.getArea();
        shape.render(area);
    });
}

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);
</code></pre></li>

<li><p>Interface Segregation Principle (ISP)</p>

<p>JavaScript doesn&rsquo;t have interfaces so this principle doesn&rsquo;t apply as strictly as others. However, it&rsquo;s important and relevant even with JavaScript&rsquo;s lack of type system.</p>

<p>ISP states that &ldquo;Clients should not be forced to depend upon interfaces that they do not use.&rdquo; Interfaces are implicit contracts in JavaScript because of duck typing.</p>

<p>A good example to look at that demonstrates this principle in JavaScript is for classes that require large settings objects. Not requiring clients to setup huge amounts of options is beneficial, because most of the time they won&rsquo;t need all of the settings. Making them optional helps prevent having a &ldquo;fat interface&rdquo;.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class DOMTraverser {
    constructor(settings) {
        this.settings = settings;
        this.setup();
    }

    setup() {
        this.rootNode = this.settings.rootNode;
        this.animationModule.setup();
    }

    traverse() {
    }
}

const $ = new DOMTraverser({
    rootNode: document.getElementsByTagName('body'),
    animationModule() {} // Most of the time, we won't need to animate when traversing.

});
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class DOMTraverser {
    constructor(settings) {
        this.settings = settings;
        this.options = settings.options;
        this.setup();
    }

    setup() {
        this.rootNode = this.settings.rootNode;
        this.setupOptions();
    }

    setupOptions() {
        if (this.options.animationModule) {
        }
    }

    traverse() {
    }
}

const $ = new DOMTraverser({
    rootNode: document.getElementsByTagName('body'),
    options: {
        animationModule() {}
    }
});
</code></pre></li>

<li><p>Dependency Inversion Principle (DIP)</p>

<p>This principle states two essential things:</p>

<ul>
<li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
<li>Abstractions should not depend upon details. Details should depend on abstractions.</li>
</ul>

<p>This can be hard to understand at first, but if you&rsquo;ve worked with AngularJS, you&rsquo;ve seen an implementation of this principle in the form of Dependency Injection (DI). While they are not identical concepts, DIP keeps high-level modules from knowing the details of its low-level modules and setting them up. It can accomplish this through DI. A huge benefit of this is that it reduces the coupling between modules. Coupling is a very bad development pattern because it makes your code hard to refactor.</p>

<p>As stated previously, JavaScript doesn&rsquo;t have interfaces so the abstractions that are depended upon are implicit contracts. That is to say, the methods and properties that an object/class exposes to another object/class. In the example below, the implicit contract is that any Request module for an InventoryTracker will have a requestItems method.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class InventoryRequester {
    constructor() {
        this.REQ_METHODS = ['HTTP'];
    }

    requestItem(item) {}
}

class InventoryTracker {
    constructor(items) {
        this.items = items;

        // BAD: We have created a dependency on a specific request implementation.
        // We should just have requestItems depend on a request method: `request`

        this.requester = new InventoryRequester();
    }

    requestItems() {
        this.items.forEach((item) =&gt; {
        this.requester.requestItem(item);
        });
    }
}

const inventoryTracker = new InventoryTracker(['apples', 'bananas']);
inventoryTracker.requestItems();
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class InventoryTracker {
    constructor(items, requester) {
        this.items = items;
        this.requester = requester;
    }

    requestItems() {
        this.items.forEach((item) =&gt; {
        this.requester.requestItem(item);
        });
    }
}

class InventoryRequesterV1 {
    constructor() {
        this.REQ_METHODS = ['HTTP'];
    }

    requestItem(item) {}
}

class InventoryRequesterV2 {
    constructor() {
        this.REQ_METHODS = ['WS'];
    }

    requestItem(item) {}
}

// By constructing our dependencies externally and injecting them, we can easily
// substitute our request module for a fancy new one that uses WebSockets.

const inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());
inventoryTracker.requestItems();
</code></pre></li>
</ol>

<h4 id="testing-a-name-testing-a">Testing <a name="testing"></a></h4>

<ol>
<li><p>Single concept per test</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">import assert from 'assert';

describe('MakeMomentJSGreatAgain', () =&gt; {
    it('handles date boundaries', () =&gt; {
        let date;

        date = new MakeMomentJSGreatAgain('1/1/2015');
        date.addDays(30);
        assert.equal('1/31/2015', date);

        date = new MakeMomentJSGreatAgain('2/1/2016');
        date.addDays(28);
        assert.equal('02/29/2016', date);

        date = new MakeMomentJSGreatAgain('2/1/2015');
        date.addDays(28);
        assert.equal('03/01/2015', date);
    });
});
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">import assert from 'assert';

describe('MakeMomentJSGreatAgain', () =&gt; {
    it('handles 30-day months', () =&gt; {
        const date = new MakeMomentJSGreatAgain('1/1/2015');
        date.addDays(30);
        assert.equal('1/31/2015', date);
    });

    it('handles leap year', () =&gt; {
        const date = new MakeMomentJSGreatAgain('2/1/2016');
        date.addDays(28);
        assert.equal('02/29/2016', date);
    });

    it('handles non-leap year', () =&gt; {
        const date = new MakeMomentJSGreatAgain('2/1/2015');
        date.addDays(28);
        assert.equal('03/01/2015', date);
    });
});
</code></pre></li>
</ol>

<h4 id="concurrency-a-name-concurrency-a">Concurrency <a name="concurrency"></a></h4>

<ol>
<li><p>Use Promises, not callbacks</p>

<p>Callbacks aren&rsquo;t clean, and they cause excessive amounts of nesting. With ES2015/ES6, Promises are a built-in global type. Use them!</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">import { get } from 'request';
import { writeFile } from 'fs';

get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', (requestErr, response) =&gt; {
    if (requestErr) {
        console.error(requestErr);
    } else {
        writeFile('article.html', response.body, (writeErr) =&gt; {
        if (writeErr) {
            console.error(writeErr);
        } else {
            console.log('File written');
        }
        });
    }
});
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">import { get } from 'request';
import { writeFile } from 'fs';

get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')
.then((response) =&gt; {
    return writeFile('article.html', response);
})
.then(() =&gt; {
    console.log('File written');
})
.catch((err) =&gt; {
    console.error(err);
});
</code></pre></li>
</ol>

<h4 id="error-handling-a-name-errorhandling-a">Error Handling <a name="errorhandling"></a></h4>

<ol>
<li><p>Don&rsquo;t ignore caught errors</p>

<p>Doing nothing with a caught error doesn&rsquo;t give you the ability to ever fix or react to said error. Logging the error to the console (console.log) isn&rsquo;t much better as often times it can get lost in a sea of things printed to the console. If you wrap any bit of code in a try/catch it means you think an error may occur there and therefore you should have a plan, or create a code path, for when it occurs.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">try {
    functionThatMightThrow();
} catch (error) {
    console.log(error);
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">try {
    functionThatMightThrow();
} catch (error) {
    // One option (more noisy than console.log):

    console.error(error);
    // Another option:

    notifyUserOfError(error);
    // Another option:

    reportErrorToService(error);
    // OR do all three!

}
</code></pre></li>

<li><p>Don&rsquo;t ignore rejected promises</p>

<p>For the same reason you shouldn&rsquo;t ignore caught errors from try/catch.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">getdata()
.then((data) =&gt; {
    functionThatMightThrow(data);
})
.catch((error) =&gt; {
    console.log(error);
});
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">getdata()
.then((data) =&gt; {
    functionThatMightThrow(data);
})
.catch((error) =&gt; {
    // One option (more noisy than console.log):

    console.error(error);
    // Another option:

    notifyUserOfError(error);
    // Another option:

    reportErrorToService(error);
    // OR do all three!

});
</code></pre></li>
</ol>

<h4 id="formatting-a-name-formatting-a">Formatting <a name="formatting"></a></h4>

<ol>
<li><p>Use consistent capitalization</p>

<p>JavaScript is untyped, so capitalization tells you a lot about your variables, functions, etc. These rules are subjective, so your team can choose whatever they want. The point is, no matter what you all choose, just be consistent.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">const DAYS_IN_WEEK = 7;
const daysInMonth = 30;

const songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];
const Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];

eraseDatabase() {}
restore_database() {}

class animal {}
class Alpaca {}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">const DAYS_IN_WEEK = 7;
const DAYS_IN_MONTH = 30;

const SONGS = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];
const ARTISTS = ['ACDC', 'Led Zeppelin', 'The Beatles'];

eraseDatabase() {}
restoreDatabase() {}

class Animal {}
class Alpaca {}
</code></pre></li>

<li><p>Function callers and callees should be close</p>

<p>If a function calls another, keep those functions vertically close in the source file. Ideally, keep the caller right above the callee. We tend to read code from top-to-bottom, like a newspaper. Because of this, make your code read that way.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">class PerformanceReview {
    constructor(employee) {
        this.employee = employee;
    }

    lookupPeers() {
        return db.lookup(this.employee, 'peers');
    }

    lookupManager() {
        return db.lookup(this.employee, 'manager');
    }

    getPeerReviews() {
        const peers = this.lookupPeers();
        // ...
    }

    perfReview() {
        this.getPeerReviews();
        this.getManagerReview();
        this.getSelfReview();
    }

    getManagerReview() {
        const manager = this.lookupManager();
    }

    getSelfReview() {
    }
}

const review = new PerformanceReview(employee);
review.perfReview();
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">class PerformanceReview {
    constructor(employee) {
        this.employee = employee;
    }

    perfReview() {
        this.getPeerReviews();
        this.getManagerReview();
        this.getSelfReview();
    }

    getPeerReviews() {
        const peers = this.lookupPeers();
        // ...
    }

    lookupPeers() {
        return db.lookup(this.employee, 'peers');
    }

    getManagerReview() {
        const manager = this.lookupManager();
    }

    lookupManager() {
        return db.lookup(this.employee, 'manager');
    }

    getSelfReview() {
    }
}

const review = new PerformanceReview(employee);
review.perfReview();
</code></pre></li>
</ol>

<h4 id="comments-a-name-comments-a">Comments <a name="comments"></a></h4>

<ol>
<li><p>Only comment things that have business logic complexity.</p>

<p>Comments are an apology, not a requirement. Good code mostly documents itself.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">hashIt(data) {
    // The hash

    let hash = 0;

    // Length of string

    const length = data.length;

    // Loop through every character in data

    for (let i = 0; i &lt; length; i++) {
        // Get character code.

        const char = data.charCodeAt(i);
        // Make the hash

        hash = ((hash &lt;&lt; 5) - hash) + char;
        // Convert to 32-bit integer

        hash &amp;= hash;
    }
}
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">hashIt(data) {
    let hash = 0;
    const length = data.length;

    for (let i = 0; i &lt; length; i++) {
        const char = data.charCodeAt(i);
        hash = ((hash &lt;&lt; 5) - hash) + char;
        // Convert to 32-bit integer

        hash &amp;= hash;
    }
}
</code></pre></li>

<li><p>Don&rsquo;t leave commented out code in your codebase</p>

<p>Version control exists for a reason. Leave old code in your history.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">doStuff();
// doOtherStuff();
// doSomeMoreStuff();
// doSoMuchStuff();
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">doStuff();
</code></pre></li>

<li><p>Don&rsquo;t have journal comments</p>

<p>Remember, use version control! There&rsquo;s no need for dead code, commented code, and especially journal comments. Use git log to get history!</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">
    /**
    * 2016-12-20: Removed monads, didn't understand them (RM)
    * 2016-10-01: Improved using special monads (JP)
    * 2016-02-03: Removed type-checking (LI)
    * 2015-03-14: Added combine with type-checking (JR)
    */
    combine(a, b) {
        return a + b;
    }
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">combine(a, b) {
    return a + b;
}
</code></pre></li>

<li><p>Avoid positional markers</p>

<p>They usually just add noise. Let the functions and variable names along with the proper indentation and formatting give the visual structure to your code.</p>

<p>BAD CODE:</p>

<pre><code class="language-Javascript">////////////////////////////////////////////////////////////////////////////////
// Scope Model Instantiation
////////////////////////////////////////////////////////////////////////////////

$scope.model = {
    menu: 'foo',
    nav: 'bar'
};

////////////////////////////////////////////////////////////////////////////////
// Action setup
////////////////////////////////////////////////////////////////////////////////

const actions = function() {
};
</code></pre>

<p>GOOD CODE:</p>

<pre><code class="language-Javascript">$scope.model = {
    menu: 'foo',
    nav: 'bar'
};

const actions = function() {
};
</code></pre></li>
</ol>
    
<div id="disqus_thread"></div>
<script>
    (function () {
        var d = document, s = d.createElement('script');
        s.src = 'https://https-hoangtranson-github-io-my-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript> 

  </main>

          <footer role="contentinfo">
  
  
</footer>

        </div>
      </div>
    </div>
    <script src="https://hoangtranson.github.io/my-blog/js/prism.js"></script>
<script src="https://hoangtranson.github.io/my-blog/js/dom-scripts.js"></script>

    
    
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-118292467-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  </body>
</html>
